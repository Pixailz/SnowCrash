we have a token file with random characters
we also have a binary file that we cannot reverse or [sl]trace

when we give the binary file an argument, it outputs something that looks like it has been ciphered.

giving it this output: 
```bash
level09@SnowCrash:~$ printf "\x01%.0s" {0..255} | xxd
0000000: 0101 0101 0101 0101 0101 0101 0101 0101  ................
0000010: 0101 0101 0101 0101 0101 0101 0101 0101  ................
0000020: 0101 0101 0101 0101 0101 0101 0101 0101  ................
0000030: 0101 0101 0101 0101 0101 0101 0101 0101  ................
0000040: 0101 0101 0101 0101 0101 0101 0101 0101  ................
0000050: 0101 0101 0101 0101 0101 0101 0101 0101  ................
0000060: 0101 0101 0101 0101 0101 0101 0101 0101  ................
0000070: 0101 0101 0101 0101 0101 0101 0101 0101  ................
0000080: 0101 0101 0101 0101 0101 0101 0101 0101  ................
0000090: 0101 0101 0101 0101 0101 0101 0101 0101  ................
00000a0: 0101 0101 0101 0101 0101 0101 0101 0101  ................
00000b0: 0101 0101 0101 0101 0101 0101 0101 0101  ................
00000c0: 0101 0101 0101 0101 0101 0101 0101 0101  ................
00000d0: 0101 0101 0101 0101 0101 0101 0101 0101  ................
00000e0: 0101 0101 0101 0101 0101 0101 0101 0101  ................
00000f0: 0101 0101 0101 0101 0101 0101 0101 0101  ................
level09@SnowCrash:~$ 
```

gives this result:
```bash
level09@SnowCrash:~$ ./level09 "$(printf "\x01%.0s" {0..255} )" | xxd
0000000: 0102 0304 0506 0708 090a 0b0c 0d0e 0f10  ................
0000010: 1112 1314 1516 1718 191a 1b1c 1d1e 1f20  ............... 
0000020: 2122 2324 2526 2728 292a 2b2c 2d2e 2f30  !"#$%&'()*+,-./0
0000030: 3132 3334 3536 3738 393a 3b3c 3d3e 3f40  123456789:;<=>?@
0000040: 4142 4344 4546 4748 494a 4b4c 4d4e 4f50  ABCDEFGHIJKLMNOP
0000050: 5152 5354 5556 5758 595a 5b5c 5d5e 5f60  QRSTUVWXYZ[\]^_`
0000060: 6162 6364 6566 6768 696a 6b6c 6d6e 6f70  abcdefghijklmnop
0000070: 7172 7374 7576 7778 797a 7b7c 7d7e 7f80  qrstuvwxyz{|}~..
0000080: 8182 8384 8586 8788 898a 8b8c 8d8e 8f90  ................
0000090: 9192 9394 9596 9798 999a 9b9c 9d9e 9fa0  ................
00000a0: a1a2 a3a4 a5a6 a7a8 a9aa abac adae afb0  ................
00000b0: b1b2 b3b4 b5b6 b7b8 b9ba bbbc bdbe bfc0  ................
00000c0: c1c2 c3c4 c5c6 c7c8 c9ca cbcc cdce cfd0  ................
00000d0: d1d2 d3d4 d5d6 d7d8 d9da dbdc ddde dfe0  ................
00000e0: e1e2 e3e4 e5e6 e7e8 e9ea ebec edee eff0  ................
00000f0: f1f2 f3f4 f5f6 f7f8 f9fa fbfc fdfe ff00  ................
level09@SnowCrash:~$ 
```

from this, we can simply see the cipher and encryption used : take the current byte `str[i]` and add its index to itself like that `str[i] += i`
we then extract the given token file, our ciphertext, and apply our algorithm to it
with a quick python2 script, this is the result: 
```py
cipher = "66 34 6b 6d 6d 36 70 7c 3d 82 7f 70 82 6e 83 82 44 42 83 44 75 7b 7f 8c 89 0a"
bytes = []
for byte in str.split(" "):
	bytes += chr(int(byte, 16))

print(bytes)
 >>> ['f', '4', 'k', 'm', 'm', '6', 'p', '|', '=', '\x82', '\x7f', 'p', '\x82', 'n', '\x83', '\x82', 'D', 'B', '\x83', 'D', 'u', '{', '\x7f', '\x8c', '\x89', '\n']

i = 0
for byte in bytes:
    bytes[i] = chr(ord(byte) - i)
    i += 1

print(bytes)
 >>> ['f', '3', 'i', 'j', 'i', '1', 'j', 'u', '5', 'y', 'u', 'e', 'v', 'a', 'u', 's', '4', '1', 'q', '1', 'a', 'f', 'i', 'u', 'q', '\n']
"".join(bytes)
 >>> 'f3iji1ju5yuevaus41q1afiuq\n'
```
```bash
level09@SnowCrash:~$ su flag09
Password: f3iji1ju5yuevaus41q1afiuq
Don't forget to launch getflag !
flag09@SnowCrash:~$ getflag
Check flag.Here is your token : s5cAJpM8ev6XHw998pRWG728z
flag09@SnowCrash:~$ 
```